<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fiquebot – Translate & Enrich</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- ====== BACKEND ROUTING ======
       When opened from your Static Web App domain, calls go to App Service.
       When opened from FastAPI /ui locally, it uses same-origin. -->
  <script>
    window.BACKEND_BASE =
      (location.hostname === 'orange-dune-0ea42a603.1.azurestaticapps.net' ||
       location.hostname.endsWith('.azurestaticapps.net'))
        ? 'https://fique-csv-cng0ewddbhhwebe8.westeurope-01.azurewebsites.net'
        : ''; // same-origin for local FastAPI /ui
    function pickBackend() { return window.BACKEND_BASE; }
  </script>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-5xl mx-auto p-6 space-y-6">
    <header class="flex items-center justify-between gap-3">
      <div>
        <h1 class="text-2xl font-bold">Fiquebot – Self-Service Translation & Entity Extraction</h1>
        <p class="text-xs text-gray-500">Frontend: single-file, SWA + App Service ready</p>
      </div>
      <div class="text-right">
        <div class="text-[11px] text-gray-500">Backend:</div>
        <div class="flex items-center gap-2">
          <code id="backendUrl" class="text-[11px] bg-gray-200 px-2 py-1 rounded select-all"></code>
          <button id="copyBackend" class="text-[11px] px-2 py-1 rounded bg-gray-900 text-white">Copy</button>
        </div>
        <div id="healthBadge" class="mt-1 text-[11px]"></div>
      </div>
    </header>

    <!-- Tabs -->
    <nav class="flex gap-2">
      <button data-tab="upload" class="tab-btn px-4 py-2 rounded-xl bg-gray-900 text-white">Upload & Process</button>
      <button data-tab="existing" class="tab-btn px-4 py-2 rounded-xl bg-gray-200">Process Existing Blob</button>
      <button data-tab="translate" class="tab-btn px-4 py-2 rounded-xl bg-gray-200">Translate Tester</button>
    </nav>

    <!-- Upload & Process -->
    <section id="tab-upload" class="tab-panel bg-white rounded-2xl shadow p-5 space-y-4">
      <h3 class="font-semibold">Upload file & process</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <label class="block">
          <span class="text-sm">File (.xlsx / .xls / .xlsm / .csv)</span>
          <input id="fileInput" type="file" accept=".xlsx,.xls,.xlsm,.csv" class="mt-1 w-full rounded-xl border px-3 py-2 bg-white" />
        </label>
        <label class="block">
          <span class="text-sm">Text column (optional)</span>
          <input id="textColumnUpload" class="mt-1 w-full rounded-xl border px-3 py-2" placeholder="e.g., message" />
        </label>
      </div>
      <div class="flex items-center gap-3">
        <button id="btnUploadProcess" class="px-4 py-2 rounded-xl bg-emerald-600 text-white">Upload & Process</button>
        <span id="uploadStatus" class="text-sm text-gray-600"></span>
      </div>
      <div id="uploadDownloadLink" class="hidden">
        <a id="downloadLinkUpload" class="text-emerald-700 underline">Download enriched CSV</a>
      </div>
    </section>

    <!-- Process Existing Blob -->
    <section id="tab-existing" class="tab-panel hidden bg-white rounded-2xl shadow p-5 space-y-4">
      <h3 class="font-semibold">Process an existing blob in <code>incoming/</code></h3>
      <div class="grid md:grid-cols-2 gap-4">
        <label class="block">
          <span class="text-sm">Blob name (must start with <code>incoming/</code>)</span>
          <input id="blobName" class="mt-1 w-full rounded-xl border px-3 py-2" placeholder="incoming/sample.xlsx" />
        </label>
        <label class="block">
          <span class="text-sm">Text column (optional)</span>
          <input id="textColumnExisting" class="mt-1 w-full rounded-xl border px-3 py-2" placeholder="e.g., message" />
        </label>
      </div>
      <div class="flex items-center gap-3">
        <button id="btnProcessExisting" class="px-4 py-2 rounded-xl bg-indigo-600 text-white">Process</button>
        <span id="existingStatus" class="text-sm text-gray-600"></span>
      </div>
      <div id="existingDownloadLink" class="hidden">
        <a id="downloadLinkExisting" class="text-indigo-700 underline">Download enriched CSV</a>
      </div>
    </section>

    <!-- Translate Tester -->
    <section id="tab-translate" class="tab-panel hidden bg-white rounded-2xl shadow p-5 space-y-4">
      <h3 class="font-semibold">Translate Tester</h3>
      <div class="grid md:grid-cols-2 gap-4">
        <label class="block">
          <span class="text-sm">Texts (one per line)</span>
          <textarea id="textsInput" rows="6" class="mt-1 w-full rounded-xl border px-3 py-2"></textarea>
        </label>
        <label class="block">
          <span class="text-sm">Target language</span>
          <input id="targetLang" value="en" class="mt-1 w-full rounded-xl border px-3 py-2" />
        </label>
      </div>
      <div class="flex items-center gap-3">
        <button id="btnTranslate" class="px-4 py-2 rounded-xl bg-sky-600 text-white">Translate</button>
        <span id="translateStatus" class="text-sm text-gray-600"></span>
      </div>
      <pre id="translateOutput" class="bg-gray-100 rounded-xl p-3 text-sm overflow-auto"></pre>
    </section>

    <!-- Logs -->
    <section class="bg-white rounded-2xl shadow p-5 space-y-3">
      <div class="flex items-center justify-between">
        <h2 class="font-semibold">Logs</h2>
        <div class="flex items-center gap-3">
          <label class="text-xs text-gray-600 inline-flex items-center gap-1">
            <input id="autoScroll" type="checkbox" class="rounded" checked />
            Auto-scroll
          </label>
          <button id="clearLogs" class="text-xs px-2 py-1 rounded bg-gray-200">Clear</button>
        </div>
      </div>
      <pre id="logs" class="bg-gray-100 rounded-xl p-3 text-xs h-56 overflow-auto"></pre>
      <div class="text-[11px] text-gray-500">
        This panel shows <b>browser logs</b> and also streams <b>server logs</b> from <code>GET /logs</code> (last 500 lines, polled every 5s).
      </div>
    </section>
  </div>

  <script>
    // ----- Tiny helpers -----
    const $ = (id) => document.getElementById(id);
    const backendBase = pickBackend();
    $('backendUrl').textContent = backendBase || '(same-origin)';
    $('copyBackend').addEventListener('click', async () => {
      await navigator.clipboard.writeText(backendBase || location.origin);
      toast('Backend URL copied.');
    });

    function toast(msg) {
      console.log('[toast]', msg);
    }

    // client log buffer (so we can re-render if needed)
    const clientLogs = [];
    function logln(...args) {
      const line = args.map(a => (typeof a === 'string' ? a : JSON.stringify(a))).join(' ');
      clientLogs.push(line);
      appendToLogPanel(line);
      console.log(...args);
    }
    function appendToLogPanel(line) {
      const el = $('logs');
      el.textContent += line + '\n';
      if ($('autoScroll').checked) el.scrollTop = el.scrollHeight;
    }

    $('clearLogs').addEventListener('click', () => {
      clientLogs.length = 0;
      $('logs').textContent = '';
    });

    function filenameFromContentDisposition(h) {
      if (!h) return null;
      const m = /filename="?([^"]+)"?/i.exec(h);
      return m ? m[1] : null;
    }
    function setActiveTab(name) {
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.add('hidden'));
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('bg-gray-900', 'text-white'));
      $(`tab-${name}`).classList.remove('hidden');
      document.querySelector(`.tab-btn[data-tab="${name}"]`).classList.add('bg-gray-900', 'text-white');
    }
    document.querySelectorAll('.tab-btn').forEach(b => b.addEventListener('click', () => setActiveTab(b.dataset.tab)));
    setActiveTab('upload'); // default tab

    // ----- Health ping on load -----
    (async function pingBackend() {
      try {
        const url = backendBase + '/health';
        logln('GET', url);
        const r = await fetch(url, { cache: 'no-store' });
        const txt = await r.text();
        logln('Response', r.status, txt || '(empty)');
        $('healthBadge').innerHTML =
          r.ok
            ? '<span class="inline-block px-2 py-0.5 rounded bg-emerald-100 text-emerald-700">/health OK</span>'
            : '<span class="inline-block px-2 py-0.5 rounded bg-rose-100 text-rose-700">/health FAILED</span>';
      } catch (e) {
        $('healthBadge').innerHTML =
          '<span class="inline-block px-2 py-0.5 rounded bg-rose-100 text-rose-700">/health ERROR</span>';
        logln('Ping failed:', e.toString());
      }
    })();

    // ----- Upload & process -----
    $('btnUploadProcess').addEventListener('click', async () => {
      const btn = $('btnUploadProcess');
      const file = $('fileInput').files[0];
      const textCol = $('textColumnUpload').value.trim();
      const status = $('uploadStatus');
      const dlWrap = $('uploadDownloadLink');
      const dlA = $('downloadLinkUpload');
      dlWrap.classList.add('hidden');
      status.textContent = '';
      if (!file) {
        status.textContent = 'Pick a .xlsx/.xls/.xlsm/.csv file.';
        return;
      }
      setDisabled(btn, true);
      try {
        const fd = new FormData();
        fd.append('file', file);
        if (textCol) fd.append('text_column', textCol);
        const url = backendBase + '/process-upload';
        logln('POST', url, '(multipart/form-data)', file.name);
        const resp = await fetch(url, { method: 'POST', body: fd });
        logln('Response', resp.status);
        const bodyTxt = await resp.clone().text().catch(() => null);
        if (!resp.ok) {
          status.textContent = 'Processing failed';
          logln('Error body:', bodyTxt || '(no body)');
          alert('Processing failed: ' + (bodyTxt || resp.statusText));
          return;
        }
        const disp = resp.headers.get('Content-Disposition');
        const fname = filenameFromContentDisposition(disp) || (file.name.replace(/\.[^.]+$/, '') + '_enriched.csv');
        const outBlob = await resp.blob();
        const href = URL.createObjectURL(outBlob);

        // auto-download
        const a = document.createElement('a');
        a.href = href; a.download = fname; document.body.appendChild(a); a.click(); a.remove();

        // also show a persistent link
        dlA.href = href;
        dlA.download = fname;
        dlWrap.classList.remove('hidden');
        status.textContent = 'Done. File downloaded.';
        logln('Ready to download:', fname);
      } catch (e) {
        status.textContent = 'Error (see logs).';
        logln('Upload/Process error:', e.toString());
        alert('Error: ' + e.toString());
      } finally {
        setDisabled(btn, false);
      }
    });

    // ----- Process existing blob -----
    $('btnProcessExisting').addEventListener('click', async () => {
      const btn = $('btnProcessExisting');
      const blobName = $('blobName').value.trim();
      const textCol = $('textColumnExisting').value.trim();
      const status = $('existingStatus');
      const dlWrap = $('existingDownloadLink');
      const dlA = $('downloadLinkExisting');
      dlWrap.classList.add('hidden');
      status.textContent = '';
      if (!blobName || !blobName.startsWith('incoming/')) {
        status.textContent = "Provide a blob name like 'incoming/sample.xlsx'.";
        return;
      }
      setDisabled(btn, true);
      try {
        const q = new URLSearchParams();
        q.set('blob_name', blobName);
        if (textCol) q.set('text_column', textCol);
        const url = backendBase + '/process-xlsx?' + q.toString();
        logln('POST', url);
        const resp = await fetch(url, { method: 'POST' });
        logln('Response', resp.status);
        const bodyTxt = await resp.clone().text().catch(() => null);
        if (!resp.ok) {
          status.textContent = 'Processing failed';
          logln('Error body:', bodyTxt || '(no body)');
          alert('Processing failed: ' + (bodyTxt || resp.statusText));
          return;
        }
        const disp = resp.headers.get('Content-Disposition');
        const baseIn = blobName.split('/').pop() || 'file';
        const fname = filenameFromContentDisposition(disp) || (baseIn.replace(/\.[^.]+$/, '') + '_enriched.csv');
        const outBlob = await resp.blob();
        const href = URL.createObjectURL(outBlob);

        // auto-download
        const a = document.createElement('a');
        a.href = href; a.download = fname; document.body.appendChild(a); a.click(); a.remove();

        // also show a persistent link
        dlA.href = href;
        dlA.download = fname;
        dlWrap.classList.remove('hidden');
        status.textContent = 'Done. File downloaded.';
        logln('Ready to download:', fname);
      } catch (e) {
        status.textContent = 'Error (see logs).';
        logln('Process existing error:', e.toString());
        alert('Error: ' + e.toString());
      } finally {
        setDisabled(btn, false);
      }
    });

    // ----- Translate tester -----
    $('btnTranslate').addEventListener('click', async () => {
      const btn = $('btnTranslate');
      const out = $('translateOutput');
      const status = $('translateStatus');
      out.textContent = '';
      status.textContent = '';
      const lines = $('textsInput').value.split('\n').map(s => s.trim()).filter(Boolean);
      const to = $('targetLang').value.trim() || 'en';
      if (lines.length === 0) {
        status.textContent = 'Enter one or more lines.';
        return;
      }
      setDisabled(btn, true);
      try {
        const url = backendBase + '/translate';
        const resp = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ texts: lines, to })
        });
        logln('POST', url, resp.status);
        const j = await resp.json().catch(() => ({}));
        if (!resp.ok) throw new Error(JSON.stringify(j));
        out.textContent = JSON.stringify(j, null, 2);
        status.textContent = 'OK';
      } catch (e) {
        status.textContent = 'Error (see logs).';
        logln('Translate error:', e.toString());
      } finally {
        setDisabled(btn, false);
      }
    });

    function setDisabled(el, v) {
      if (!el) return;
      el.disabled = !!v;
      el.classList.toggle('opacity-50', !!v);
      el.classList.toggle('pointer-events-none', !!v);
    }

    // ===== Server logs polling (/logs) =====
    // We keep an index of how many lines we've displayed to avoid re-appending duplicates.
    let serverLogCursor = 0;
    async function pollServerLogs() {
      const url = backendBase + '/logs';
      try {
        const resp = await fetch(url, { cache: 'no-store' });
        if (!resp.ok) {
          logln('GET', url, '->', resp.status);
          return;
        }
        const data = await resp.json();
        const lines = Array.isArray(data.logs) ? data.logs : [];
        // append only new lines since last poll
        if (lines.length > serverLogCursor) {
          for (let i = serverLogCursor; i < lines.length; i++) {
            appendToLogPanel(lines[i]);
          }
          serverLogCursor = lines.length;
        }
      } catch (e) {
        logln('Log fetch error:', e.toString());
      }
    }
    setInterval(pollServerLogs, 5000);
    // initial kick
    pollServerLogs();
  </script>
</body>
</html>
